Fetch API data using useEffect: 
useEffect(() => {
 
  const fetchData = async () => {
    try {
      const response = await fetch("https://api.example.com/data");
     
      // Check if the request was successful (status code 200)
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
 
      // Parse the response as JSON
      const data = await response.json();
 
      // Now you can work with the 'data'
      console.log(data);
    } catch (error) {
      console.error("Error fetching data:", error);
    }
  };
 
  // Call the async function
  fetchData();
}, [])

Exact same way as in vanilla JS but we place the aysnc function inside the useEffect hook. We give an empty array dependency so that useffect occurs on page load. You can have a dependency (i.e. postcode) if your api will fetch based on different postcodes hence this fetch will occur after the dependency (postcode) has changed and will update the query URL.


Handling errors

Throw new Error (‘’) - this will display the error message you wrote within the ()

Catch(err) {console.error(err.message} -  err.message is used because error is an object (BECAUSE NEW ERROR is a constructor). You can customise it e.g. catch(err) 
{console.error(‘New error detected:` err.message}.
However if you don’t have a ‘throw new error’ then err.message returns the default message set by the javascript run time



Example use of clean up function to abort fetching:

To understand this we first need to know what abort controller is.

AbortController is a feature provided by the JavaScript Fetch API, and it allows you to control and abort fetch requests. 
We use ‘new AbortController()’ constructor to create an object. 
This object contains the property called signal
This signal is a key and holds abortSignal object
AbortSignal has its own properties (Aborted which is a boolean is false by default)
abortController.abort() is a method provided by AbortController to initiate the abortion process. When we call the abort() method this will turn ‘aborted’ inside abortSignal from ‘false’ to ‘true’ . Other parts of your code can check the aborted property to react accordingly, such as canceling ongoing operations or handling the abortion in some way.

Visual representation:
Controller = {
 	 	signal: AbortSignal {
    		aborted: false, // boolean


  		}
}


// Therefore, in the code below we create a ‘controller’ object and we select the signal property and assign it to a variable. 


Then to attach the abortSignal (signal) to the fetch we place it in {}. This is because fetch() has a ‘options’ object and we are placing the signal inside that object. 
const Controller = new AbortController();


const signal = Controller.signal;


const response = await fetch(url, { signal });



Step by step breakdown of how to use abort controller and clear up function:

Create an instance of AbortController:
const abortCont = new AbortController();
const signal = abortCont.signal;


Pass the signal to the fetch request:

const fetchData = async () => {
 
    const response = await fetch(url, { signal });

Add the abortController.abort() method to the cleanup function:

return () => {
  abortCont.abort(); // Abort the fetch when the component unmounts or when the dependency changes


}

The .abort() method throws a new error and gets caught in the ‘catch’ block. So if you have other code that will be rendered or executed in the catch block that you don’t want to execute then you must update the catch block and include an if statement like so:

catch(err){
  if (err.name === ‘AbortError’){
    console.log('fetch aborted');
  }
  else {
    // code you want to execute on error handling NOT INDUCED by abort.
  }
}

err.name - is because each error has a name and when we use abort method the error name is AbortError 
Conditional rendering:

In react we sometimes only want to render things onto the DOM based on a condition being true. Since we cant use if else statements in JSX the only way to do continental rendering is by using a ternary operator or &&.

In React, the && operator is used for conditional rendering. It works differently than in vanilla JavaScript. Here's how it works in React:
If the expression on the left of && is truthy, React renders the component on the right of &&.
If the expression on the left is falsy, React doesn't render the component on the right, and the entire expression evaluates to null (or undefined).
So, in the code you provided:

{blogs && <Blogs blogs={blogs} title='new blog' />}

If blogs is truthy (not null, undefined, false, 0, or an empty string), React will render the <Blogs ... /> component.
If blogs is falsy (e.g., null), React won't render the <Blogs ... /> component, and the expression evaluates to null.

This is a concise way to conditionally render a component in React based on the truthiness of a variable. It's a common pattern used to handle cases where you want to render something only if a certain condition is met.

An example when This is used is  when you want to display something based on the fetch API. Whereby you use a state variable and set it to null and based on the fetch api data you use statefunction(fetchAPI DATA) to render the info to the page. However, since fetch is asynchronous it takes time therefore the default value of state variable is rendered. - this can lead to errors/page not loading because you’re rendering ‘null’ therefore we use conditional rendering to tell react that only render if the left argument in && is true.
So this is typically used with useState.