What are components:
Components are functions that return JSX code. You write these functions inside the app.jsx file. When you want to import that component to display on the index.html, you must insert it inside the reactDOM.createlement in the main.jsx file. 

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

The <App /> is the component we are importing from the app.jsx to the html.
The react.strictMode tags are there for safety reasons when theres been a change to the react code base (nothing to do with me)

Components are building blocks for your website. These components act as blueprint to create multiple copies of the same thing just by referencing the component source. This is similar to classes whereby we create multiple objects just by using the class name as the reference.
Therefore when creating a component, the name of the function must be with a capital letter like so:

function Post() {
   
}

^ This is because the app I am building will have multiple social media posts so I want to make a post component so that I can use it multiple times.

At the top of every component file you create you must have 
import React from "react"

Included into it, why? in your React components file, you need to import React from the react library. This is because when you write JSX (which is a syntax extension for JavaScript used with React), it gets transpiled into calls to React.createElement. Therefore, React must be in scope for JSX to work.





Once you have your components made you must export and import them. To export them you must type at the bottom of the file you’re trying to export ‘export default Name of your function’

E.g. 

function Post() {
  return (
    <div>
      <p>A-B-D-U-L</p>
      <p>React.js is awesome!</p>
    </div>
  );
}


export default Post;




You then import the components to the app.jsx file and it will look like this:

import Post from "./components/Posts";


function App() {
  return <Post />;
}


export default App;

We’re basically passing the Post component to the app.Jsx file which is the root component, this then gets imported to the main.Jsx file and it will be displayed on the webpage.


How to export multiple items from a file:

To export and import modules the best way to do it is at the bottom of your file you do
export {} and inside the {} you type the name of the variables you want to export and just comma separate them.

Then on the file you want to import them you just copy that export object into that file but replace export with important and finish it off to say where its from

Example:

const func1 = () => {};


const func2 = () => {};


const func3 = () => {};


export { func1, func2, func3 };




import { func1, func2, func3 } from "file Name";


// Now you can use func1, func2, and func3




How to reuse components?

To do this you simply go to your parent component (i.e. the app() function in our example) and you insert the html semantic you want your component to displayed on i.e. div, aside, section, nav or main

You then just copy and paste your component within that semantic like so:


function App() {
  return (
    <section>
      <Post />
      <Post />
    </section>
  );
}

You must wrap your multiple instances of components in an another container, in this example we use <section>
Summary:

Components are functions
Each component must be in its own component file
Each function name must be the same as the component name and with a capital letter (BOTH COMPONENT FILE AND FUNCTION NAME must be a capital letter)
Must import React from “react”
Must return jsx code
Steps to adding component to main.jsx file:
Export your component
Go to main.jsx file and import your component
In the render method between the react.strictMode tags you add your component, the syntax for inserting the component is <Component name /> 


Adding Elements in Component

If you want your component to have multiple elements then you must wrap them under 1 parent element and have the elements you want as children of that element. This is because when converting jsx to js, jsx only takes into account 1 element but if you have multiple elements it won’t know which one to convert, hence wrapping all the elements under 1 parent will convert that parent element and its contents.

Syntax:

const CreateTodo = () => {
   return (
    <div>
      <h1>Create New To Do List</h1>
      <button>Add task</button>
    </div>
  );
};

^ As you can see the h2 and button elements are wrapped in a div parent container.

As you have noticed we then wrap the entire return block in a (), this so that jsx knows that all these elements are 1 code block, similar to how in vanilla JS we use {} to reference a code block. 

In short: In React, when you want to return multiple elements or a block of JSX, you need to wrap them in parentheses. 

However, there is an issue with wrapping elements with a div - The issue is that this renders the div onto the page itself so when you inspect the html doc on the browser that div will be present. Therefore to overcome the issue of having every component wrapped in div, we use a react property called react.fragment. We simply put these react.fragment in place of the div, like so:

const CreateTodo = () => {
  return (
    <React.Fragment>
      <h1>Create New To Do List</h1>
      <button>Add task</button>
    </React.Fragment>
  );
};

The parentheses are still used though.

You can write react.fragment in another way and its simply just leaving the tag empty like so:

    <>
      <h1>Create New To Do List</h1>
      <button>Add task</button>
    </>


Its best to use the latter version of react fragment as it makes the code cleaner
JavaScript expression in JSX;

To explain this, I must use an example:

const namesArray = ["Sonic", "Tails"];


function Post() {
  let chosenName = Math.random() > 0.5 ? namesArray[0] : namesArray[1];
  return (
    <div>
      <p>Sonic</p>
      <p>React.js is awesome!</p>
    </div>
  );
}

Currently in this function we’re only outputting what we hardcoded (which is ‘sonic’) but what if we want to output the result of an array, variable or api etc… to do that we need to use the {} curly braces syntax.

Within the {} we can input the variable name thus allowing jsx to execute that variable for example 

 <div>
      <p>{chosenName}</p>
      <p>React.js is awesome!</p>
    </div>

Similar to template literals but without the $ sign

We can put any js expression within the {} e.g. function, variable, objects, array.

E.g. of returning a function 

const CreateTodo = () => {
  let tasks = 0;
  const countTask = () => {
    return tasks;
  };
  return (
    <>
      <h1>tasks: {countTask()} </h1>
      <button>Add task</button>
    </>
  );
};


^ remember If you want to display the value of the function then you must invoke the function with (). 

IMPORTANT:

 If we are rendering the JS expression to appear on the DOM then JSX will convert whatever is in the {} into a string for example we have an array [1,2,3] if we wrap this array in {} and have it displayed on the DOM then it will be converted into a string and show on the DOM as 123.

This only happens when we want to reflect the JS expression onto the DOM otherwise the JS expression will be in its natural form.

const CreateTodo = () => {
  let characters = ["sonic", "tails", "shadow"];


  return <p>{characters}</p>;
};

On the DOM it will look like sonictailsshadow


Classes:

Whenever you want to add a class in JSX you have to use className=””, you can't use class=”” because html already uses that, therefore it will create conflicting issues.

Summary:

Whenever you’re using vanilla JS properties (i.e. arrays, objects, variables, functions) on jsx, you must place them inside {}. This is the syntax for telling JSX that we are referring to a vanilla JS expression.
You can write any kind of JS inside these {} e.g. you can have ternary statements {x = true ? Hello : Goodbye}
To add classes in jsx use className
 


CSS styling in React:

You can add CSS styling in 3 ways


Index.css file - This will be the main css stylesheet, this is like normal css and you’ll just refer to the elements you want to style e.g. You have a component that has a header tag so now you can select ‘header’ or its class name. As you know React follows html semantics so you can’t have multiple headers etc..
Individual CSS file for each component - Typical practice is that every component has their own css file. You have to make sure you import the CSS file to the top of the component file so that it connects.
To do this you will have to make a different folder called ‘styles’ and then create css sheets for each component.You then import the css file to the component via ../styles/compnentname.css
In-line styling - Basically inside the JSX element tag you do style={}, the reason we use {} is because we’re going to add a JS expression here which is an object. This object will contain key value pairs for css. And since we’re using an object we’ll need a 2nd set of {} to showcase that. For example: style={ {backgroundColor: ‘blue’, color: ‘white’} }

The most important thing to note is that you must import CSS FILES correctly otherwise the stylesheet won’t render.

Events in React:

In react, we add inline events 

<button onClick={} >Add task</button>

We need to pass a function within the {}. This function we must create ourselves and give it a name ‘handle name of event` e.g. handleClick or handleDoubleClick. 

So you create your event handler and give it the code block you want to execute, you then reference that function inside the {} without invoking the function. E.g. 

const CreateTodo = () => {
  let tasks = 0;
  const handleClick = () => {
    console.log(`button was clicked`);
  };
  return (
      <button onClick={handleClick}>Add task</button>
  );
};

^ This code is saying, when button is clicked, run the function ‘handleClick’

If we had onClick={handleClick()} this will invoke the function before we even click the button.
Event with parameters, how do we incorporate that? 

As you know if we include a () after the function it will invoke it before the event takes place, so if we want to pass an argument to that function we do so by doing:

Const handleClick = (name) => console.log(`${name} has clicked this button`)

<button onClick={handleClick(“Jon”}>Click me</button> – THIS IS INCORRECT as it will call the handleclick function before the event is triggered.

To overcome this, we wrap the event handle in an arrow function. This is basically saying, on click we carry out this function and this function is returning the handleclick function.


<button onClick={ () => { handleClick(“Jon”) } }>Click me</button> – THIS IS CORRECT

So that it makes sense. Every event returns a function but here we’re defining what we want to return on the global scope. So we just reference the function to attach it to the event. However if we want to include parameters to the global function then we must pass the global function as a nested function of the event function. 


We only need to do this wrapping when we have parameters we want to push as arguments. 
In the case of event listeners where we have the event parameter we don’t need to do this. We only need to write the event parameters on the handle function, no need to include it on the onClick{}. Why, well because common sense, were placing the global function inside the onClick{} so since its already got the event parameter on the global we don’t need to use () inside the {} to call the function. We only use the wrapping of functions when we want to pass arguments into a function.  


What is react state?

If you have noticed on that click event, if you had a counter on the display and you want to update that counter by clicking that event. Unfortunately in react the function will execute but the display won’t be updated. 

E.g. 
let tasks = 0;
  const handleClick = () => {
tasks ++ 
    console.log(`button was clicked`, tasks);
  };
  return (
<h1>tasks: {tasks]</h1>
      <button onClick={handleClick}>Add task</button>


So here if we click the button, the console.log will display the message and increment the tasks number. However, the h1 on the webpage won’t increment. Therefore to update the DOM we have to use state.

Why? This is because when we use normal JS variables/expressions and then those change, react doesn’t register it on the DOM. Therefore to display changes to JS variables/expressions on the DOM we need to use state.

State: allows us to manage and display the changing data in our application 
If we use a state variable opposed to a normal JS variable then react can update the DOM as intended. In simple words, state is used to tell react, ‘watch this variable and if it changes then reflect the change on the DOM’ 
How to define a variable as a state variable - We will need to use Hooks


Hooks:

Hooks are functions that make functional components work like class components, thus giving us access to react features. These features are by default present on class components but since now our components are functions we have to implement them using hooks.

All hooks have a ‘use’ prefix e.g. useState, useEffect 
Before we can use a hook, we must import it from the react library
Like so  import React, { useState } from "react"
Basically, you update the import code at the top of your react component and add a comma and in an object insert the hook that you will use. 
useState Hook:

How to use the useState hook? So far our example looks like this:

import React, { useState } from "react";


const CreateTodo = () => {
  let tasks = 0;
  const handleClick = () => {
    tasks++;
    console.log(`button was clicked`, tasks);
  };
  return (
    <>
      <h1>Tasks: {tasks} </h1>
      <button onClick={handleClick}>Add task</button>
    </>
  );
};

The next step is to add the useState() into the functional component and within the () type the default value of the variable, so in this example the default value is 0 so we do useState(0). 
useState() returns an array containing 2 items, 1st is the default value of the variable and the 2nd is function you want to execute.
So for example we store the hook in a variable called countArray = useState(0). Console.log it and you will see the array with 2 items.
State variable: Now is the important part, now you have the value you can create a variable to host this value hence making it a state variable 
You must also store the state function into its own variable and use the prefix ‘set’ in its name to follow normal react naming convention practice

 countArray = useState(0)
Count = countArray[0]
setCount = countArray[1]  - We are basically storing this function and giving it a name

Now within your component jsx within the {} of the JS expression you input the state variable and not the JS normal variable.

So how do we update the state variable? Since we stored the state function in the setCount variable. Whatever value we pass in setCount function, will be the value of this count variable.

So if we want to update the count number from 0 to 1. We do setCount(count + 1). This function will take the count and increment it by 1.

This is what the final code should look like:   
import React, { useState } from "react";


const CreateTodo = () => {
  let countArray = useState(0);
  let count = countArray[0];
  let setCount = countArray[1];


  const handleClick = () => {
    setCount(count + 1);
    console.log(`button was clicked`);
  };
  return (
    <>
      <h1>Tasks: {count} </h1>
      <button onClick={handleClick}>Add task</button>
    </>
  );
};

This code is saying, create a useState hook and assign it the value of 0. Then store it in an array and extract the value and the function so that we can use them as independent variables.
The ‘count’ is the state variable that can be updated on the DOM and we use the state function ‘setCount’ to change the value of the state variable. Because you can only update the value of a state variable using a state function

However, this looks too untidy and hence we should use array destructuring to clean the code like so:

let [count, setCount] = useState(0);

Since useState returns an array we can destructure it from the start instead of giving its own variable. So instead of writing the 3 lines of code (below) we can use one line. The code below is just for understanding the concept.

  let countArray = useState(0);
  let count = countArray[0];
  let setCount = countArray[1];




This is how the final code should look:

const CreateTodo = () => {
  let [count, setCount] = useState(0);


  const handleClick = () => {
    setCount(count + 1);
    console.log(`button was clicked`);
  };
  return (
    <>
      <h1>Tasks: {count} </h1>
      <button onClick={handleClick}>Add task</button>
    </>
  );
};
We are destructuring the useState Array at the top of the functional component (This is a must to make it global for any nested functions (think lexical scope).
On the event handler we insert the useState function with the code we want to execute

Easy way to remember is step 1) Destructure the useState, step 2) Use the state variable and function where needed.

Final note: When you refresh the page, the count will reset back to 0 because that was the default value..
Summary:
Hooks are functions that give react properties to functional components
useStake hook returns an array. Within the () of the useState() you insert the default value of the variable.
This array contains 2 items, 1st one is the value, the 2nd is the function.
Storing these two items in a variable will make them state variable and state function
In order to update the DOM we must use state variables instead of normal variables. These state variables can only be changed using the state function 
The state function name is given using the prefix ‘set’ followed by the name we give the state variable.
How to use state function: call the state function i.e. setCount() and within the () you type in the change you want to induce on the state variable e.g. state variable + 1
In the useState() you can have any value here i.e. an array, boolean, string etc, literally anything that you would be changing and thus will lead to a change in the DOM.


In React, When use useState, it creates the state function and variable as a pair and so when you call the statefunction (e.g., setInput or setCount), React internally associates that function with a specific state variable. So you may see sometimes that state function doesn’t refer to the state variable directly. 



Map, lists and keys:

Map method:

In your component if you have an array and you want to display that array as list items you will have to do the following:

Define your array e.g. let characters = [“Sonic”, “Tails”, “Shadow”]
Then go to the html part of the jsx and incorporate your map method. This means since we want to display the characters as list items we will create an UNORDERED LIST within the tags of the UL list we will add a JS expression (which will be our map method) so we have to use {} whenever we’re referring to a JS expression. 
Know the map method returns something when it iterates over the array, in this case we want the map method to return a li item containing the array item. And again since we’re extracting a JS variable we need to use {} in the li - The reason we use {} within the li is because react will treat any text not wrapped in {} as html and not js expression but since we want to reference the items in the array we do this.
This all sounds confusing but will make sense when you see the example below.

const CreateTodo = () => {


  let character = ["sonic", "tails", "shadow"];
  return (
    <>
      <ul>
        {character.map((value) => {
          return <li>{value}</li>;
        })}
      </ul>
    </>
  );

^ This code is mapping over our array and in each iteration we are producing a list item containing the name of the item. 
The most important thing to note when using map method is:
Wrap the map method in {}
Wrap the array item you want displayed in {} - Since we want to display the array items inside the li we wrap it. This is because each item in the array is considered a JS variable/expression hence we must wrap it when we want to reference it


Very good lesson here:

const Content = () => {
  const [items, setItems] = useState([
    {
      id: 1,
      checked: false,
      item: "Almonds",
    },
    {
      id: 2,
      checked: false,
      item: "Milk",
    },
    {
      id: 3,
      checked: false,
      item: "Kiwi",
    },
  ]);


  return (
    <>
      <ul>
        {items.map((item) => {
          return <li>{item.item}</li>;
        })}
      </ul>

^ I created this useState and gave it an array as the default (i.e. once the page loads, this is what the array will look like). I then rendered the items as list items.

Now what if I want to dynamically change one of the items say ‘milk’ to ‘Brazils’? 


The only way to change an item and render it is we must create a new array using the map method. Within the new array we just assign the ‘milk’ to ‘Brazils’

We then pass this new map method array to the setItem() function to update the item value from the default array to the new array and render the change on the DOM.

For example:

const updateItems = items.map((item) =>
  return item.id === 2 ? { ...item, item: 'Brazils' } : item
);

setItems(updatedItems);    – THEN WE CALL stateFunction and pass the new array. Remember in the useState creation the () holds the default value but everytime we want to change that default value we just call the stateFunction() and pass in the new value we want the state variable to hold

What this is code is doing is:
Creating a new array using the map method

Checks to see if id is = 2 and if it is the it spreads that object (thus exposing the id, checked and item keys)

Note: We are not destructuring the object, we are simply spreading the object into another object (Remember in spread operator lesson, when we want to spread an array we have to put it into another array, this is the same thing. We are creating a new object and then assigns the item: ‘Brazil’s 

I know from vanilla JS I am used to changing object properties using objectname.key = new property name or using [] notation. But in react you have to use this approach. Whereby when we spread an object into a new object we assign names of properties as if we’re writing the object from scratch,just the spread operator makes it so we don’t type in the whole object manually again. 

If having troubles with Map array and you’re not sure why its not working its because you have a habit of missing out the return keyword:

- Check if you have the return keyword in the map array code block, you must always have that present.


Mapping summary:
Use cases for map():
We use map() when we want display items from an array on the DOM
We use map() to change the value within  
Whenever you’re using map() to place in the DOM you must wrap using the {} and again {} for targeting the specific array items


Keys:

Every list item created in react must have a ‘key’ attribute. The key attribute helps React identify which items have changed, been added, or been removed.

In the example above, I haven’t done that hence on the console you would’ve got an error message saying “each list item should have its own unique key”. 

So in the li tag just add the key attribute e.g. <li key=”anyname”> </li>

YOU DON’T USE THE KEY ATTRIBUTE FOR ANYTHING, ITS JUST FOR REACT BEHIND THE SCENES STUFF. All you need to know is that you must have it for each list item.







Higher order functions and Closures:
This is a very important concept you need to grasp. Basically, You know that functions nested in other functions have access to the parent functions scope data (variables etc..) This is what closures are - its child functions having access to parent function data. 

Higher order functions are functions that use a function as a parameter or return a function. The latter creates the ‘closure’ logic



  const [items, setItems] = useState([
    { id: 1, label: 'Brazils', checked: false },
    { id: 2, label: 'Almonds', checked: false },
    { id: 3, label: 'Coconut', checked: false },
  ]);


  const handleCheckbox = (id) => {
      let newArray = items.map((item) => {
        return item.id === id ? { ...item, checked: !item.checked } : item
      })


      setItems(newArray)
    ;
  };


  return (
    <div>
      <h2>Checkbox List</h2>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            <label>
              <input
                type="checkbox"
                checked={item.checked}
                onChange={() => handleCheckbox(item.id)}
              />
              {item.label}
            </label>
          </li>
        ))}
      </ul>
    </div>
  );
};

^ In this example we have 3 list items created via the map method. Within the map method we created an input field that houses a ‘handleclick function’ this is a nested function of the map method. This nested function takes a parameter item.id. 

So how this works is that on each iteration of the map method, each li element is given access to the ‘item’ of that current iteration. Therefore item.checked and item.id are referencing the item that is being iterated and selecting its key. (THIS IS CLOSURE)

Now when the user triggers the ‘handlecheckbox’ event by clicking on a list item, since the item.id is already known due to closure, when this event is triggered it already has the item.id value and the sequence continues. 


Props:

What are Props?
Definition: "Props" is short for "properties" and is a special keyword in React.
Role: Props allow you to pass data from a parent component to a child component (individual components)
How to Use Props?
Passing Props:


In the parent component (where the child component is used), you pass values as attributes within the component tag. These are considered the ‘arguments’ for props
// Parent Component (main.jsx)
<ChildComponent propName="propValue" />



Receiving Props:

In the child component, you receive props as an argument to the component function.

// Child Component
const ChildComponent = (props) => {
 Access props using props.propName
You write props inside the child component () making ‘props’ the parameter. You then select the prop by using props.propname but if you’re wanting to refer to the prop in jsx you'll have to wrap it in {} 
Example:
// main.jsx
import React from 'react';
import ChildComponent from './ChildComponent';
const ParentComponent = () => {
  return <ChildComponent message="Hello from Parent!" />;
};
// ChildComponent.jsx
import React from 'react';
const ChildComponent = (props) => {
  return <p>{props.message}</p>;
};
export default ChildComponent;
Very useful tip: 
Inside the child component () function, props are stored in an object. Therefore we can use object destructuring to list out the props instead of using ‘props’ e.g.
const ChildComponent = ({message}) => {
  return <p>{message}</p>;
Default props: 
We can add default prop values in case in the parent component we don’t pass any prop arguments and this is how to use them.

ChildComponent.defaultProps = {
message: ‘No value given’
Message2: …
Message3: …
}
Here you can add as many props as you will be using in the object. E.g. if you had message2 you’ll also give it a default value.

Note: You add the default props after the child components closing bracket, just before the export code lines.




Recap:
Props are similar to function parameters. You write the ‘props’ inside the child component (). And you pass the arguments on the main.jsx file (parent component) on the child component tag. 
Props are given in an object hence we use dot notation


The most important aspect of props is prop drilling: 
Prop drilling is using the parent component (main.jsx or app.jsx file) to hold important variables/data sets that will be reused in multiple components. Since variables are specific to a child component they can’t be passed to other child components. 
The only way to pass variables to multiple child components is to host them within a parent component. We then use props to send down these variables to the child components. 
For example:
//ChildComponent 


Const child =() => {
const [items, setItems] = useState([
    { id: 1, label: 'Brazils', checked: false },
    { id: 2, label: 'Almonds', checked: false },
    { id: 3, label: 'Coconut', checked: false },
  ]);


  const handleClick = (id) => {
      let newArray = items.map((item) => {
        return item.id === id ? { ...item, checked: !item.checked } : item
      })


      setItems(newArray)
    ;
  };


  return (
    <div>
      <h2>Checkbox List</h2>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            <label>
              <input
                type="checkbox"
                checked={item.checked}
                onChange={() => handleClick(item.id)}
              />
              {item.label}
            </label>
          </li>
        ))}
      </ul>
    </div>
  );
};

We want to make the list in this child component global along with the handleCheckbox function and useState() hook so that other components can use them too. 
What we do is move them to a parent component and assign them as props to the child components
// Parent component
const [items, setItems] = useState([
    { id: 1, label: 'Brazils', checked: false },
    { id: 2, label: 'Almonds', checked: false },
    { id: 3, label: 'Coconut', checked: false },
  ]);




  const handleClick = (id) => {
      let newArray = items.map((item) => {
        return item.id === id ? { ...item, checked: !item.checked } : item
      })




      setItems(newArray)
    ;
  };
 <div>
      <Card item={items}, handleClick ={handleClick} />
      <Component 2 />
      <Content />
    </div>

^ When passing down values from the parent to the child we write the values were assigning the props in {}. As you can see above we gave the card component a prop name of item but we assigned it the ‘items’ which refers to the state variable.
We then move over to the child component file and object destructure the prop names, LIKE SO:
const Card = ({items, handleClick}) => {
  return (
    <>
      <ul>
        {items.map((item) => {
          return <li key={item.id}>{item.item}</li>;
        })}
      </ul>
      <button onClick={handleClick}></button>
    </>

^ This is what the child component will look like at the end, it has its JSX done as normal but the information(data) is being passed down from the parent component as props
**Make sure to import any useState or css stuff into the parent component so that all of it works as intended.





Prop drilling:
Is the process of passing props from parent to child to child to child.
So that means if You’re using a click event on a button, but this button has its own component file. You may also have 2 other components files i.e. section component and form component. So for the button component to receive the data from the parent component it’ll have to be passed from the parent -> section component -> form component -> button component.
All you have to know to do prop drilling is just repeat the steps above but for each child component.
Example to make it all make sense and how to use functions with parameters in prop drills ( hint: we don’t give the parameter within the parent) 
// Grandparent Component (Grandparent.jsx):
const Grandparent = () => {
  const handleClick = () => {
    console.log('Button clicked in Grandparent!');
  };
  return (
    <div>
      <h1>Grandparent Component</h1>
      <Parent handleClick={handleClick} /> // NO parameter here.
    </div>
  );
};
export default Grandparent;


// Parent Component (Parent.jsx):
const Parent = ({ handleClick }) => {
  return (
    <div>
      <h2>Parent Component</h2>
      <Child onButtonClick={handleClick} />
    </div>
  );
};


// Child Component (Child.jsx):
const Child = ({ onButtonClick }) => {
  return (
    <div>
      <h3>Child Component</h3>
      <button onClick={onButtonClick}>Click me!</button>

End result: We create the function in the Grandparent, then pass the data to the parent and then to the child. The child uses the data and does something with it.

If we want to pass a parameter to the function then on the child we would add the argument e.g.
<button onClick={() => {onButtonClick(argument)}}>Click me!</button>



That means we are passing props to each child component. The Prop drilling problem is that some child components ( section and form components ) will be having props that are unused and the only reason they have them is so that they can relay the data down to the final child component. This also is a problem because if there is a bug or a change we have to make, we’ll have to change all the props in all of the components. 
Prop drilling is okay for small applications but not for larger ones as it gets harder to manage/maintain
To overcome the issue of deep prop drilling we use context API

context API:
Context API is a way for a React component to share information with its descendants, no matter how deeply nested they are in the component tree
How to use it:
Within the parent component, Create a variable and assign it ‘  React.createContext()   ‘. Naming convention is after the name you follow it with the word context so its easily understandable. This variable is just like in DOM we do variable name = document.createElement. So we use the name as our lead 
E.g. const themeContext =  React.createContext()
Inside the parent components ‘return’ code block you create the context tags (as if its a html element). This will wrap around all the components that you want to access the context api data.
Here you use the variable name.Provider - This is because the variable will be providing these child components with data.
Inside the opening tag we use ‘value’ keyword to show we are passing these as props. The ‘value’ and here was assign the ‘value’ an object of the items we want to pass down. So again we use JS expression {} along with object {} syntax so we’ll have 2 sets of {}.
E.g. 
Return (
<>
       <themeContext.provider    value = {  {state Variable}  }>	

	<child1 />
	<child2 />
	<child3 />
       </themeContext.provider>
</>)
The powerful thing about context api is that All the components wrapped within the provider element get access to the value( i.e. props) and any subsequent child component and so for. Its like a bloodline, once it's in, it's passed down to all components no matter how deep. 


So now that the child components have access to the prop passed from the context, how do we use it?
You have to use the useContext hook. So in the child component you must import it from react
Say we have this example from the parent. 
Const [theme, setTheme] = useState('light');
return (
<ThemeContext.Provider value={ { theme, setTheme} }>
)
We use useContext in the child component using destructing (similar to useState) i.e.  we insert the object we have imputed in the provider ‘value’ like so 
Const {theme, setTheme} = useContext(themeContext)
Now that we have inserted the context to the child, we can use the props ‘theme’ and ‘setTheme’


Summary:
When you use React.createContext(), it returns:
Provider: A React component that allows components to use context changes.
Consumer: A React component that USES context changes. In modern React we use the useContext hook instead of Consumer.

Here's a step-by-step breakdown on how to use context API: 


// 1) Create Context:
const themeContext = React.createContext();


// 2) Provide Values:


const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');


  return (
    <themeContext.Provider value={{ theme, setTheme }}>
      <childcomp />
    </themeContext.Provider>
  );
};


// 3) Consume Values    // Don’t forget to import useContext hook!!
const ChildComp = () => {
  const { theme, setTheme } = useContext(themeContext);


  return (
    <div>
      <p>Current Theme: {theme}</p>





How to pass multiple props using context api?
So in the provider tags, we have value, the value is syntax and must be there. This value represents an object that holds all the props and in JSX syntax with context api we don’t need to give key-value pair, we just input the name of the variables we want to pass as props directly. Similar to destructuring but its not and its only viable in context api.


Single values we’d do value={{variable1}} 
SO the syntax is VALUE={ {variable1, variable2} }
So instead of returning 1 jsx expression were returning multiple so we have to place them in an object.  
E.g. 
const [theme, setTheme] = useState('light');
return (
  <ThemeContext.Provider value={{ theme, setTheme }}>
	{children}
</ThemeContext.Provider>

Forms and Inputs: 

Handling user inputs:

let Form = () => {
  const [input, setinput] = useState("");


  const handleChange = (e) => {
    setinput(e.target.value);
  };
  return (
    <>
      <input type="text" onChange={handleChange} />
      <h1>input: {input} </h1>
    </>
  );
};

In the input field add onChange event and assign it a function (event handler)
Define that function using the handle… naming convention
Give it the event parameter. This event parameter is used to target what the user is inputting so we use e.target.value (i.e. take the value of the input field)
Since we want to display the users input on the DOM we have to use ‘useState’. 
We then on the html part insert how we want to display the users input (in this example we used a h1) 
In the state function() we insert the e.target.value - this is basically saying ‘update the input (state variable) with e.target.value’ and since we’ve linked the state variable to the h1 it will display there. 


Forms - step by step guide to controlling inputs:


In this example we will have useState;
const [title, setTitle] = useState(' ')    -- Whenever we're dealing with controlled inputs/forms we assign the state variable a default state of empty string.


 In react we want to keep track of user inputs especially when working with forms. And in order to do so we must keep track of the state.

Therefore, we do this by giving input fields a value attribute (value = ), this value represents the contents of the input field. 

Since we want the value to match the state variable so that we can keep track of it and change state we must assign value to the state variable.  i.e. value = {title} This makes it a controlled input.


Next, we add an 'onChange' event listener, in this event we add the anonymous function and give it the event parameter (just like if you're writing a vanilla JS event listener function).
Inside the function code block we call the state function and within the () we update the title (state variable) to e.target.value i.e. onChange={(e) => {setTitle(e.target.value)} }

This will then keep track of the input fields value and if we're to add an 'add' button we can then display user's input onto the DOM.

Here's a breakdown:
// 1) State Initialization:
// Initialize a state variable (title) with an initial state of an empty string.


const [title, setTitle] = useState('');
// 2)Input Field Setup:
<form>
<input
  type="text"
  value={title}
  onChange={(e) => setTitle(e.target.value)}
/>
</form>

Form submission:
If you want to submit the form, you have to add an ‘onSubmit’ event listener like so:
const handleSubmit = (e) => {
  e.preventDefault();
  settitle(``) // This will reset the input value back to an empty string. otherwise the user input will still contain the previous search as the default.
}
  <form onSubmit={handleSubmit}>
  </form>

How to update the DOM upon form submission (say you want to add another list item on a grocery list)
make a function called ‘addItem’ with a parameter(so that we can pass the state variable as an argument).
Within the code block we create a variable to add the new item to the existing array like so  const newArray = [...originalArray, newItem]
We then call this function with the state variable as an argument onto the ‘onSubmit’ event handler. This will 
So this will be the full code:
const GroceryList = () => {
  const [groceryList, setGroceryList] = useState([]); // Original list items
  const [title, setTitle] = useState(''); // This is for the new list items we’ll add (i.e. controlled input)


  const addNewItemFunction = (item) => {
    setGroceryList([...groceryList, item]);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    addNewItemFunction(title);
    setTitle('');
  };
  return (
    <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
        />
        <button type="submit">Add Item</button>
      </form>
      <ul>
        {groceryList.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>

Incorporating local storage so that when the page reloads it doesn’t go back to the default state variable but to the local storage.
This is done at the very end of your form (i.e. final step, so only do this after you’ve completed everything). 
Make the state Variable default value  the JSON.parse(localSotrage.getItem(‘....’)
Add localStorage.setItem(‘groceryList’, JSON.stringify(controlled input state variable) to the function that will add the new item to a new array. 
const GroceryList = () => {
  const [groceryList, setGroceryList] = useState((JSON.parse(localStorage.getItem('shoppingList')))); // This makes the data in local storage the default value of the state variable. Therefore, when the user reloads they get the saved list.


Whenever you are retrieving data from local storage you must use || [] - this is to prevent an error from ruining the application if there is no item in local storage. Because in your example about its telling use to get shopping list but what if it doesn’t exist
correct code is JSON.parse(localStorage.getItem('shoppingList' || []))
  const [title, setTitle] = useState("");


  const addNewItemFunction = (item) => {
    setGroceryList([...groceryList, item]);
    localStorage.setItem("shoppingList", JSON.stringify(title)); // This adds the controlled input state variable to local storage.
  };


useEffect Hook: 
Syntax:
useEffect(() => {}, [])
Useffect is a callback function used to carry out side-effects.


useEffect(callbackFunction, [dependencies])
callbackFunction is the code that performs the side effect.
[dependencies] is an optional array that specifies when the useEffect should run based on changes in state.

Purpose of useEffect:
useEffect is used in React to manage side effects, which are actions that occur outside the normal flow of the application (e.g., data fetching, subscriptions, or cleanup operations).


Three Variations of useEffect:


Without dependencies: Runs on every render. So if a state changes in the component, this will render the component and thus running useEffect too.
useEffect(() => {})
With an empty dependency array: Runs only on mount
useEffect(() => {}, [])
With dependencies: Runs when the specified dependencies change.
useEffect(() => {}, [postCode])


Clean-Up Function and Component Lifecycle:
Clean up function is when we return another function inside the useEffect code block. I.e. after our primary function. 
syntax 
Return () => {
	code block
}
When useEffect has a clean-up function, it runs before the component unmounts or before the next useEffect run (in case of dependencies).
Component Lifecycle Stages:
Mounting: Component is created and added to the DOM.
Updating: Component re-renders due to changes in state or props.
Unmounting: Component is about to be removed from the DOM.
A common use case is clearing up resources like event listeners, timers, or subscriptions.
No clean up means if you have a continuous code (timer or fetch) it will continue to process regardless of state change AND if that is coupled with dependency changes (i.e. state change), useEffect is rendered again and you get concurrent things happening
With clean up function you can prevent side effect codes from continuing when they are not required anymore.

We use a clean up function in times where the user closes a modal, clicks on a different page etc…

Best Practices:
Focus on using useEffect for side effects things like fetching API, changes to DOM, saving items to local storage and make the items the dependency,, setTimeout setInterval

NEVER set state directly inside useEffect to prevent infinite loops

NEVER use non-primitive data types (arrays, objects, function) as dependency. This is because In JavaScript, variables that hold non-primitive data types (like objects or arrays) actually store a reference to the memory location where that data is stored. 
Now, when you create a new object or array, even if the contents are the same, it gets stored in a different memory location. As a result, the reference to this new memory location is different from the reference of the previous one.
In React, when you have a dependency in a hook like useEffect. React checks if the references of those dependencies have changed to determine whether to re-run the effect or memoization. If the reference changes, React assumes the content has changed, even if it looks the same, and triggers a re-render or re-execution of the effect.  THUS CAUSING INFINITE LOOPING

Example of what NOT TO DO!
 const data = { dataid: 1 };


  useEffect(() => {
    TrackEvent("pageEvent", data);
  }, [data]);


// Infinite loop is created because the dependency is an object, this changes the object location hence causing a re-render and this cycle continues.



To avoid infinite loops when using non-primitive values as dependencies you need to ensure that you're not creating a new reference to the non-primitive value on each render. Here are some strategies:
Memoization with useMemo: You can use useMemo to memoize the non-primitive value, ensuring that it only changes when its dependencies change.
const memoizedData = useMemo(() => ({ dataid: 1 }), []); // Empty dependency array means it won't change





Fetch API data using useEffect: 
useEffect(() => {
 
  const fetchData = async () => {
    try {
      const response = await fetch("https://api.example.com/data");
     
      // Check if the request was successful (status code 200)
      if (!response.ok) {
        throw new Error(`HTTP error! Status: ${response.status}`);
      }
 
      // Parse the response as JSON
      const data = await response.json();
 
      // Now you can work with the 'data'
      console.log(data);
    } catch (error) {
      console.error("Error fetching data:", error);
    }
  };
 
  // Call the async function
  fetchData();
}, [])

Exact same way as in vanilla JS but we place the aysnc function inside the useEffect hook. We give an empty array dependency so that useffect occurs on page load. You can have a dependency (i.e. postcode) if your api will fetch based on different postcodes hence this fetch will occur after the dependency (postcode) has changed and will update the query URL.


Handling errors

Throw new Error (‘’) - this will display the error message you wrote within the ()

Catch(err) {console.error(err.message} -  err.message is used because error is an object (BECAUSE NEW ERROR is a constructor). You can customise it e.g. catch(err) 
{console.error(‘New error detected:` err.message}.
However if you don’t have a ‘throw new error’ then err.message returns the default message set by the javascript run time



Example use of clean up function to abort fetching:

To understand this we first need to know what abort controller is.

AbortController is a feature provided by the JavaScript Fetch API, and it allows you to control and abort fetch requests. 
We use ‘new AbortController()’ constructor to create an object. 
This object contains the property called signal
This signal is a key and holds abortSignal object
AbortSignal has its own properties (Aborted which is a boolean is false by default)
abortController.abort() is a method provided by AbortController to initiate the abortion process. When we call the abort() method this will turn ‘aborted’ inside abortSignal from ‘false’ to ‘true’ . Other parts of your code can check the aborted property to react accordingly, such as canceling ongoing operations or handling the abortion in some way.

Visual representation:
Controller = {
 	 	signal: AbortSignal {
    		aborted: false, // boolean


  		}
}


// Therefore, in the code below we create a ‘controller’ object and we select the signal property and assign it to a variable. 


Then to attach the abortSignal (signal) to the fetch we place it in {}. This is because fetch() has a ‘options’ object and we are placing the signal inside that object. 
const Controller = new AbortController();


const signal = Controller.signal;


const response = await fetch(url, { signal });



Step by step breakdown of how to use abort controller and clear up function:

Create an instance of AbortController:
const abortCont = new AbortController();
const signal = abortCont.signal;


Pass the signal to the fetch request:

const fetchData = async () => {
 
    const response = await fetch(url, { signal });

Add the abortController.abort() method to the cleanup function:

return () => {
  abortCont.abort(); // Abort the fetch when the component unmounts or when the dependency changes


}

The .abort() method throws a new error and gets caught in the ‘catch’ block. So if you have other code that will be rendered or executed in the catch block that you don’t want to execute then you must update the catch block and include an if statement like so:

catch(err){
  if (err.name === ‘AbortError’){
    console.log('fetch aborted');
  }
  else {
    // code you want to execute on error handling NOT INDUCED by abort.
  }
}

err.name - is because each error has a name and when we use abort method the error name is AbortError 
Conditional rendering:

In react we sometimes only want to render things onto the DOM based on a condition being true. Since we cant use if else statements in JSX the only way to do continental rendering is by using a ternary operator or &&.

In React, the && operator is used for conditional rendering. It works differently than in vanilla JavaScript. Here's how it works in React:
If the expression on the left of && is truthy, React renders the component on the right of &&.
If the expression on the left is falsy, React doesn't render the component on the right, and the entire expression evaluates to null (or undefined).
So, in the code you provided:

{blogs && <Blogs blogs={blogs} title='new blog' />}

If blogs is truthy (not null, undefined, false, 0, or an empty string), React will render the <Blogs ... /> component.
If blogs is falsy (e.g., null), React won't render the <Blogs ... /> component, and the expression evaluates to null.

This is a concise way to conditionally render a component in React based on the truthiness of a variable. It's a common pattern used to handle cases where you want to render something only if a certain condition is met.

An example when This is used is  when you want to display something based on the fetch API. Whereby you use a state variable and set it to null and based on the fetch api data you use statefunction(fetchAPI DATA) to render the info to the page. However, since fetch is asynchronous it takes time therefore the default value of state variable is rendered. - this can lead to errors/page not loading because you’re rendering ‘null’ therefore we use conditional rendering to tell react that only render if the left argument in && is true.
So this is typically used with useState.

https://www.youtube.com/watch?v=qtheqr0jgIQ&list=PL4cUxeGkcC9gZD-Tvwfod2gaISzfRiP9d&index=18

https://www.youtube.com/watch?v=4oCVDkb_EIs



Custom hooks:

Custom hooks are just JavaScript functions that use one or more of the built-in React hooks.

Create a folder called customHooks
Create file with the name of your custom hook. In this example we will build a useFetch hook so the file will be called useFetch
create the component 
Import any hooks you used
Write the logic inside the component code block
In the return part of the component code block you remove the JSX and return the things you want i.e. the state variable which you’ll use 
You must give the component a parameter of ‘URL’ and inside the fetch() () you pass the parameter and inside the dependency you give ‘url’ 
Then you call this function in the component you want and pass any URL as an argument

For example

^This is what a component would look like but now we want to add that fetch stuff into a useFetch. So we must take the useEffect and state to the customhook file.


^ This is the custom useFetch hook.
As you can see we just added the logic into this useFetch component and gave it a URL parameter. The fetch() now requires a URL parameter therefore whenever we use UseFetch, whatever API we pass it will work as intended.YOU MUST GIVE ‘URL’ AS A DEPENDENCY TOO - THIS WILL ALLOW THE USEEFFECT TO RENDER WITH THE NEW URL. - this example screenshot doesn’t have it but it should.


Very important:
In the ‘return’ value When creating a custom hook, you typically return the items that other components will use. This can include state variables, state functions, or any other datatype needed by those components.. We must first wrap them in an [] or {} - This is vital because it allows for destructing when importing to other components (think of useContext and UseState). In this above example we didn’t wrap them in {} or [] because we're only returning 1 item.






^ This is what the component looks like now.

In the child component where we use the customhook we have 2 options

If we are returning multiple items from the customHook (we wrap them in {} [] as you already know) then within the child component we do destructuring to give access to those return values and then we can use them as we see fit (similar to useContext)

We return a single value (like the example above). We then store it in a variable and use it. So to clarify in this example we returned ‘response’ and so in the child component we are storing the ‘response’ from the customehook into a variable called ‘data’. Since ‘response’ was an array we can use array methods on ‘data.
In summary: whatever you return in the customhook, that will be the natural state of it in the child component. Meaning if ‘response’ was a string and not an array then ‘data’ would also be a string and we cant use array methods on it.



Simple Summary example of customhook and how to use it.:

// Custom Hook
const useCustomHook = () => {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);


  // Return an array
  return [count, increment];


  // Alternatively, return an object
  // return { count, increment };
};


// Using the Custom Hook in a Component
const MyComponent = () => {
  // Destructuring the returned values
  const [count, increment] = useCustomHook();


  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};


// count or increment can be any data type. An array or function etc… it doesn't matter. 





CRUD Operations: Create Read Update Delete

To understand CRUD you must first understand fetch(). Fetch takes a URL and has an ‘options’ object i.e. fetch(url, {} ). You already know you can add abortcontroller signal here (see clean up function example)

This options object allows you to provide additional configurations and settings for the HTTP request. This is what controls CRUD.


Here are some common properties you can include in the options object:

method:
Specifies the HTTP method of the request (e.g., GET, POST, PUT, DELETE).
Default value is "GET".

fetch('https://api.example.com/data', {
  method: 'POST',
});


headers:
An object representing the headers of the request. You can set custom headers like content type, 
fetch('https://api.example.com/data', {
  method: 'GET',
  headers: {
    'Content-Type': 'application/json',
  },
});




















Body:


The body property represents the data that you want to send with a POST. The data can be in various formats, and the way you structure the body depends on the content type you specify in the headers. In the example below we are sending application/json therefore we must use json.stringify.
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({ key: 'value' }) // sends an object


  OR 


  body: JSON.stringify(newItem) // Sends newItem variable


});





Remember to set the appropriate Content-Type header based on the type of data you're sending in the body. This helps the server understand how to interpret the data. 



Now that we know about the options object we can move on to how we can do CRUD operations;


Create a component called apiRequest - This will the function in which we pass arguments in order to carry out the fetch request and apply the CRUD methods

const apiRequest = async (url = '', optionsObject = null, errMsg = null) => {
  try {
    const response = await fetch(url, {optionsObject});
    if (!response.ok) throw new Error(`Something went wrong, reload the page`);
  } catch (error) {
    errMsg = error.message
  }
};


Next, in the child component you will have functions for Create, update and delete. (Which will update the local storage or database e.g. db.json server).
You must wrap your CRUD operation functions with ‘async’ and when you come to call the apiRequest() with arguments you must use await.

This is because 
ApiRequest is the asynchronous function (as declared in the apiRquest component) therefore it returns the fetch promise. So this function will wait until the promise inside it has been resolved.
Since Apirequest will ‘hold’ until the promise is fulfilled, that means we can’t call it immediately otherwise the promise within it won’t execute. Therefore in the CRUD function we use ‘await apiRequest()’ to signal that we are waiting for the apirequest to complete its promise before moving on.
Since we’re ‘awaiting’ we must label that crud operation function with ‘async’ 


apiRequest is async:
Your apiRequest function is marked as async because it performs asynchronous operations, specifically the fetch call.
The async keyword in the function declaration indicates that the function will return a Promise.
await apiRequest(...):
When you call apiRequest in another function (e.g., a CRUD operation function), you use await before it.
The await keyword is used to pause the execution of the current function until the Promise returned by apiRequest resolves.





Note: We don’t need to data = response.json() because we already have a fetchHook for that. We’re just dealing with the response aspect of the API by adding to it, deleting it or creating it.


Complete example:

const createResource = async () => {
  let URL = "https://api.example.com/resources";


  let createPost = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(newData),
  };
  const result = await apiRequest(URL, { createPost });
};


^ In this example we placed the options object in a variable to make the calling of apiRequest clean






NOTE: THIS IS DIFFERENT TO USEFETCH() CUSTOM HOOK. THIS IS FOR CRUD OPERATIONS CREATE, UPDATE AND DELETE BUT USEFETCH HOOK IS FOR READ



React Routing

Basics:

Intall npm react-router-dom
Import BrowserRouter from react-router-dom to the main.jsx file (i.e. file that will render to html (i.e. the one with react.strictmode))
Inside the react.strictmode you wrap the root component (usually app.jsx) with <BrowserRouter> </BrowserRouter>.  sidenote:The browserRouter acts like a useContext which then passes all the router properties to the app and its children 
Now, we go into the root element. And we must import ‘Routes’ and ‘Route’ from react-router-dom.
We add <Routes> <Routes/> and this will wrap around <route /> .(note how route is self closing.
Routes is to highlight that inside this element is a route. And for each page we want we must put it in <route/> tag.
Within the <route/> we pass it two props 1) path and 2) element. The path is the url path so if you want a home page the path will be path=’/’ if you want a contact page the path will be path=’/contact’. - basically the path is what gets added to the end of the url. When we use / it’ll just be the homepage.
The element is where we place the component we want displayed on that path e.g. element={<contact />} this will display the contact component. 

E.g. 
const App = () => {
  return (
    <Routes>


        <Route path='/' element={<HomePage />}/>
        <Route path='/About' element={<About />}/>
        <Route path='/Contact' element={<Contact />}/>


    </Routes>
  )}

So now whenever the user clicks on homepage/about/contact button on the site it will take them to a ‘new’ page that will display only that component. So this web app will have 3 pages.

If you want components to appear on all pages then you’d add them outside the ‘routes’ tag. 
E.g. the navbar will be present on all 3 pages because its not specified as a route.
 <>
      <header>
        <Navbar />
      </header>
      <main>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/About" element={<About />} />
          <Route path="/Contact" element={<Contact />} />
        </Routes>
      </main>
    </>
Now, we’ve connected the router and paths now we just need to add links to those pages
In normal HTML we use anchor tags with a href attribute however with react we use <Link> </Link> and inside the opening tag we have a ‘to’ attribute which we will assign the same value as we did for path. But again we must import Link from react-router-dom

E.g. 
   
      <li>
        <Link to="/">Home</Link>
      </li>
      <li>
        <Link to="/About">About</Link>
      </li>
      <li>
        <Link to="/Contact">Contact</Link>
      </li>

This is all great however, if we’re making a navbar we want it so that which page the user clicks on, the navbar name is highlighted to showcase which part of the page the user is on. By using <LINK> this won’t be possible. Therefore, we just simply replace link with NavLink. The only difference between the two is that when using navlink whichever link that we click on it gives it a class of ‘active’. We can then go into CSS and style the navlink via a.active { color: red } - this will color the currently active link with red. REMEMBER TO IMPORT NavLink

Personally I should be using ‘NavLink’ over Link. they’re both the same but if I want to customize it then I can.

404 error page/page not found:

Make a component and include the stuff that it should say on an error page. (for good UX include a button that will send the user to the homepage) 

The * in the path basically means if the user goes on a URL that doesn’t have any of the specified paths we have in our code then display the error component.
E.g. 

<Route path="*" element={<PageNotFound />} />


Route parameters:

Sometimes you may have a parent path that will be home to sub paths. E.g. I have a ‘products’ page and in this page I have 10 different products. I cant give each product the ‘products’ because it will overwrite the initial products page showcasing all the 10 products.
Therefore i must give them their own subclass of the products page i.e.
                  <NavLink  to=’ /products/1 ‘ > </NavLink>
      <NavLink   to=’ /products/2 ‘ > </NavLink>
                  <NavLink   to=’ /products/3 ‘ > </NavLink>
The subclasses are called route parameters

So we’ve created the links to those sub paths. Now we need to integrate the route to the sub path and we do this in the root component as follows

          <Route path='/products' element={<Products/>} />
          <Route path='/products/:id' element={<SingleProduct/>} />
^ This code is saying we have a path to the products page. Inside the products page we have other links. When you click on the link on the products page and as long as the link has the products path and subpath (e.g. to=’/products/123’) it render the singleproduct component


<Route path=’/products/:id’ />   – the :id IS THE SYNTAX FOR route parameters. It's telling the browser that there will be pages that will have extra content added to the end of their path and when its detected then render the singleProduct component. – id can be anything in the url (above we used numbers 1,2,3) but the user can type anything there and it may lead to problems and there is a fix to this which will be discussed later.


So far whenever a user clicks on one of the 3 product links it will render the SingleProduct component. But they’re all the same page - what now? We need to associate the route parameter to each of the products.
In order to use this we must import a hook called useParams() inside the singleProduct component.
UseParams will contain the route parameter within an object so when we import it we must use object destructuring to access it, for example 

Const { id } = useParams()  – The reason we use ‘id’ is because thats the name we used in the root component in the path section (/products/:id. So if we named it something else we’d put that name in the object because that's the name of the key we’re accessing. 
We can do anything with this ID now, add it to the h1 etc etc

We can use this ‘id’ to fetch data from the backend to display the correct information based on the id – this is something more advanced and for a later time.





Nested routes:

https://www.youtube.com/watch?v=WNScOybyOhg&list=PLC3y8-rFHvwjkxt8TOteFdT_YmzwpBlrG&index=8  - This vid explains nested routes to perfection

The purpose of nested routes is that only certain parts of the UI get re-rendered once a link is clicked.

^ As you can see here, when the user clicks on products it will display the products component which contains links to featured and new. When the user clicks on featured, the URL goes to products/featured but as you can see we will have part of the initial products component displayed - this is achieved through nested routes.

Step by step to make nested routes:

Create a parent page i.e products. Within the products component you add links to the other pages you want. This time though we don’t need to specify the parent path. I.e. above we were dealing with un-nested routes hence we had to use the full path (to /products/1) but with nested routes since the links are present in the parent path we bypass the parent path and go straight to the sub path i.e. 
<NavLink to=’/featured’ > Featured Items <NavLink>
<NavLink to=’/New’ > New Items <NavLink>

Now we need to configure the nested routes inside the root component

You know how each route is self closing tag, with nested routes we need that to be a full tag with its own opening and closing tag. Within that element we will add the nested component paths. Like so:

   <Route path="/products" element={<Products />}>
       <Route path="products/featured" element={<FeaturedProduct />} />
       <Route path="products/New" element={<NewProduct />} />
   </Route>
       
^here we need to specify the parent path because we’re already within its range. nested routes must provide a complete path starting from the root. So, even though you have a nested route within the /products route, you still need to include the full path, including the parent route's path, for the nested route.

Now all these routes are configured - the parent path doesn’t know where to render the child paths to. So to solve this we use the ‘Outlet’ feature of react.

So we go into the parent path (i.e. products component) and import outlet from react router dom. 
You then add this Outlet tag at the bottom of your parent path page - This way whatever is above this Outlet tag will be replicated inside the child routes. (THIS IS VERY GOOD FOR UX) And so this will display the important stuff you need from the parent path and then below it render the contents of the child component. So this is how the Parent path component will look like:

import { Link, Outlet } from 'react-router-dom';


const Products = () => {
  return (
    <>
      <form action="">
        <input type="search" placeholder="Search Item" />
      </form>


      <nav>
        <Link to='/featured'>Featured </Link>     //Again you may need to use absolute path if this shorthand doesn't work
        <Link to='/new'>new </Link>
      </nav>
      <Outlet />   // IMPORTANT ASPECT
    </>
  );
};


Index route:

This is connected to nested routes and so can only be used when theres nested routes. Whereby when you have a component that you want to be displayed on the parent paths page then the way to do this is using index route. 
For example we have a products page but we want to display the featured products on the parent product component (the user can still click featured and new but the featured component will also be displayed on the product page without the need of going to the .featured url. If we click on featured it will still go to the correct url and display what is supposed to be displayed.

On the root component (app.jsx) within the nested route, you must add a new route and instead of giving it  path=... you give it an index attribute. Then you specify the component you want to be displayed via the element attribute. 
For example:

   <Route path="/products" element={<Products />}>
            <Route index element={<FeaturedProduct />} />
            <Route path="/featured" element={<FeaturedProduct />} />
            <Route path="/New" element={<NewProduct />} />
   </Route>

Query String/Search Params:
Sometimes we may need to create filters e.g. sort by name, active users, prices etc… or when a user clicks on a video we want a specific url for that (look at the url of a youtube video it uses searchParams).
To do this we must use the hook called useSearchParams(). This hook is very similar to useState syntax

Const [searchParams, useSearchParams] = useSearchParams()

Searchparams is an object and useSearchParams is a function which sets the key-value pair of that object. - Again very similar to useState.
The only difference is that when we come to assign values to the searchparams object via the setSearchParams we must use an object literal and inside the object literal we will use key:value pair. This keyvalue pair is what will be the query string in the URL 
E.g. setSearchParams( {filter: ‘ActiveUsers’} )
Now that is in place we can use searchParams value to display any jsx or component we want via conditional rendering. Since SearchParams is an object the way we can obtain the key is via the get method. So we’ll need to create a variable
 e.g. showActiveUsers = searchParams.get(‘filter’)
showActiveUsers === ‘‘ActiveUsers’ ? <h2>Showing Active Users</h2> : <h2>Showing all users</h2> 



Why get method? – The URLSearchParams object returned by useSearchParams is designed to work similarly to the native URLSearchParams API in JavaScript. When you want to retrieve a specific parameter value, you should use the get method.

For example:
In this example I will be using a button to change the query string (note in different projects you might have something else that will invoke the setSearchParams function.

const Products = () => {
    const [searchParams, setSearchParams] = useSearchParams();
    const showActiveUser = searchParams.get('filter');
 
    return (
      <>
        <button onClick={() => { setSearchParams({ filter: "ActiveUsers" }); }}> Active users </button>
        { showActiveUser === 'ActiveUsers' ? <ActiveUser Component /> : <AllUser Component /> }
      </>

So when we click on the button the url will change to /products?filter=ActiveUsers

summary = You write this inside the page that will have the filter options 


Navigating Programmatically

So far we’ve learnt about the user clicking on the links/navlinks but too many links to click can be poor UX. so sometimes we programmatically navigate to a page e.g. in amazon when I click on ‘Submit Order’ button - it takes me to a Order confirmation page. Or if I want to click  a button that takes me back to the homepage (i.e. if the button is on the 404 page).
To navigate in this way we must use the useNavigate() hook. useNaviagte is a function.
You simply assign it to a variable. Then on the button you would use an onclick event and inside that function you’d invoke the navigate() just like we’d do with any function. And we pass it the route path we want it to go to  as the parameter
E.g. 
 <Route path='order-summary' element={<orderSummary/>} />
// THIS IS WHAT IS IN APP.JS(root component)

  // This is what you do on the relevant component where you want the button to appear. So in this example this would be our order component which has the button to submit the order
  const navigate = useNavigate()
<>
 <button onClick={() => {navigate('order-summary')}}>Submit Order</button>
</>

Tip:
If you want to create a go back button that will take the user to the previous page then you simply pass -1 as the parameter for the navigate function. There's no need to make a route in the root component for this back option..
<button onClick={() => {navigate(-1) }>Go back</button>

Summary:

UseParams
Const { id } = useParams()
useSearchParams
Const [searchParams, setSearchParams] = useSearchParams()
useNavigate
Const navigate = useNavigate()
outlet
<outlet />


Dynamically creating routes using your own JSON server:
Creating your JSON server: create a json file and add the data you want it to include.
Import the json data to your app.jsx and pass it as props to your components
Now depending on whether your JSON data was an object of objects then when you come to use in in your component you will have to convert it into an array as JSX DOES NOT RENDER OBJECTS.
If your data is an object of objects ie. object = {  product 1: {title:P1 price: 10}, Product 2: {title:P2 price: 5} } you will need to use Object.keys(nameOfObject) - this will convert the object keys into an array
We can then use array methods e.g. map() and and use the map parameter to access the name of the keys. We can use this for targeting the inner objects via square notation
E.g.  Object.keys(nameOfObject).map( (value) => { <h1>nameOfObject[value].title </h1>} – this code is saying, take the object turn its keys into an array and then map over the array and pass the array index value as [] notation and then find the title. 
Here is where you dynamically create URLs whilst you’re mapping over the keys. You simply do 
<NavLink to={`productGallery/product/${value}`}  – this will create a new url for each object key.
Then in the single product component you utilize useParams() as follows:
if (nameOfObject[id]) { const {object destructuring….} = nameofObject[id] }
– this line of code is saying, ‘if NameOfObject[URL endpoint] if its truthy i.e. it exists then execute this code. 
Here you can use else statement to move the user to 404 page not found page.

Summary: 
- You pass the JSON data as props to all the children that will use it i.e. the parent route and the child route. 
- The main aspects here is that we must extract the keys as values and then use that key to generate the dynamic url endpoints and also use that value to access the inner objects so that we can select the data within them.


